{
  "version": 3,
  "sources": ["../src/new-window.tsx", "../node_modules/run-applescript/index.js", "../src/actions/index.tsx", "../src/constants/index.ts", "../src/util/index.ts"],
  "sourcesContent": ["import { closeMainWindow, showHUD } from \"@raycast/api\";\nimport { createNewWindow } from \"./actions\";\n\nexport default async function Command() {\n  try {\n    await closeMainWindow();\n    await createNewWindow();\n  } catch {\n    await showHUD(\"\u274C Failed opening a new Google Chrome window\");\n  }\n}\n", "import process from 'node:process';\nimport {promisify} from 'node:util';\nimport {execFile, execFileSync} from 'node:child_process';\n\nconst execFileAsync = promisify(execFile);\n\nexport async function runAppleScript(script, {humanReadableOutput = true, signal} = {}) {\n\tif (process.platform !== 'darwin') {\n\t\tthrow new Error('macOS only');\n\t}\n\n\tconst outputArguments = humanReadableOutput ? [] : ['-ss'];\n\n\tconst execOptions = {};\n\tif (signal) {\n\t\texecOptions.signal = signal;\n\t}\n\n\tconst {stdout} = await execFileAsync('osascript', ['-e', script, outputArguments], execOptions);\n\treturn stdout.trim();\n}\n\nexport function runAppleScriptSync(script, {humanReadableOutput = true} = {}) {\n\tif (process.platform !== 'darwin') {\n\t\tthrow new Error('macOS only');\n\t}\n\n\tconst outputArguments = humanReadableOutput ? [] : ['-ss'];\n\n\tconst stdout = execFileSync('osascript', ['-e', script, ...outputArguments], {\n\t\tencoding: 'utf8',\n\t\tstdio: ['ignore', 'pipe', 'ignore'],\n\t\ttimeout: 500,\n\t});\n\n\treturn stdout.trim();\n}\n", "import { runAppleScript } from \"run-applescript\";\nimport { closeMainWindow, LocalStorage, popToRoot } from \"@raycast/api\";\nimport { SettingsProfileOpenBehaviour, Tab } from \"../interfaces\";\nimport { NOT_INSTALLED_MESSAGE } from \"../constants\";\n\nexport async function getOpenTabs(useOriginalFavicon: boolean): Promise<Tab[]> {\n  const faviconFormula = useOriginalFavicon\n    ? `execute t javascript \u00AC\n        \"document.head.querySelector('link[rel~=icon]') ? document.head.querySelector('link[rel~=icon]').href : '';\"`\n    : '\"\"';\n\n  await checkAppInstalled();\n\n  try {\n    const openTabs = await runAppleScript(`\n      set _output to \"\"\n      tell application \"Google Chrome\"\n        repeat with w in windows\n          set _w_id to get id of w as inches as string\n          set _tab_index to 1\n          repeat with t in tabs of w\n            set _title to get title of t\n            set _url to get URL of t\n            set _favicon to ${faviconFormula}\n            set _output to (_output & _title & \"${Tab.TAB_CONTENTS_SEPARATOR}\" & _url & \"${Tab.TAB_CONTENTS_SEPARATOR}\" & _favicon & \"${Tab.TAB_CONTENTS_SEPARATOR}\" & _w_id & \"${Tab.TAB_CONTENTS_SEPARATOR}\" & _tab_index & \"\\\\n\")\n            set _tab_index to _tab_index + 1\n          end repeat\n        end repeat\n      end tell\n      return _output\n  `);\n\n    return openTabs\n      .split(\"\\n\")\n      .filter((line) => line.length !== 0)\n      .map((line) => Tab.parse(line));\n  } catch (err) {\n    if ((err as Error).message.includes('Can\\'t get application \"Google Chrome\"')) {\n      LocalStorage.removeItem(\"is-installed\");\n    }\n    await checkAppInstalled();\n    return [];\n  }\n}\n\nexport async function openNewTab({\n  url,\n  query,\n  profileCurrent,\n  profileOriginal,\n  openTabInProfile,\n}: {\n  url?: string;\n  query?: string;\n  profileCurrent: string;\n  profileOriginal?: string;\n  openTabInProfile: SettingsProfileOpenBehaviour;\n}): Promise<boolean | string> {\n  setTimeout(() => {\n    popToRoot({ clearSearchBar: true });\n  }, 3000);\n  await Promise.all([closeMainWindow({ clearRootSearch: true }), checkAppInstalled()]);\n\n  let script = \"\";\n\n  const getOpenInProfileCommand = (profile: string) =>\n    `\n    set profile to quoted form of \"${profile}\"\n    set link to quoted form of \"${url ? url : \"about:blank\"}\"\n    do shell script \"open -na 'Google Chrome' --args --profile-directory=\" & profile & \" \" & link\n  `;\n\n  switch (openTabInProfile) {\n    case SettingsProfileOpenBehaviour.Default:\n      script =\n        `\n        set winExists to false\n        tell application \"Google Chrome\"\n            repeat with win in every window\n                if index of win is 1 then\n                    set winExists to true\n                    exit repeat\n                end if\n            end repeat\n\n            if not winExists then\n                make new window\n            else\n                activate\n            end if\n\n            tell window 1\n                set newTab to make new tab ` +\n        (url\n          ? `with properties {URL:\"${url}\"}`\n          : query\n            ? 'with properties {URL:\"https://www.google.com/search?q=' + query + '\"}'\n            : \"\") +\n        `\n            end tell\n        end tell\n        return true\n\n  `;\n      break;\n    case SettingsProfileOpenBehaviour.ProfileCurrent:\n      script = getOpenInProfileCommand(profileCurrent);\n      break;\n    case SettingsProfileOpenBehaviour.ProfileOriginal:\n      script = getOpenInProfileCommand(profileOriginal!);\n      break;\n  }\n\n  return await runAppleScript(script);\n}\n\nexport async function setActiveTab(tab: Tab): Promise<void> {\n  await runAppleScript(`\n    tell application \"Google Chrome\"\n      activate\n      set _wnd to first window where id is ${tab.windowsId}\n      set index of _wnd to 1\n      set active tab index of _wnd to ${tab.tabIndex}\n    end tell\n    return true\n  `);\n}\n\nexport async function closeActiveTab(tab: Tab): Promise<void> {\n  await runAppleScript(`\n    tell application \"Google Chrome\"\n      activate\n      set _wnd to first window where id is ${tab.windowsId}\n      set index of _wnd to 1\n      set active tab index of _wnd to ${tab.tabIndex}\n      close active tab of _wnd\n    end tell\n    return true\n  `);\n}\n\nexport async function reloadTab(tab: Tab): Promise<void> {\n  await runAppleScript(`\n    tell application \"Google Chrome\"\n      activate\n      set _wnd to first window where id is ${tab.windowsId}\n      set index of _wnd to 1\n      set active tab index of _wnd to ${tab.tabIndex}\n      tell active tab of _wnd to reload\n    end tell\n    return true\n  `);\n}\n\nconst checkAppInstalled = async () => {\n  const installed = await LocalStorage.getItem(\"is-installed\");\n  if (installed) return;\n\n  const appInstalled = await runAppleScript(`\nset isInstalled to false\ntry\n    do shell script \"osascript -e 'exists application \\\\\"Google Chrome\\\\\"'\"\n    set isInstalled to true\nend try\n\nreturn isInstalled`);\n  if (appInstalled === \"false\") {\n    throw new Error(NOT_INSTALLED_MESSAGE);\n  }\n  LocalStorage.setItem(\"is-installed\", true);\n};\n\nexport async function createNewWindow(): Promise<void> {\n  await runAppleScript(`\n    tell application \"Google Chrome\"\n      make new window\n      activate\n    end tell\n    return true\n  `);\n}\n\nexport async function createNewWindowToWebsie(website: string): Promise<void> {\n  await runAppleScript(`\n    tell application \"Google Chrome\"\n      make new window\n      open location \"${website}\"\n      activate\n    end tell\n    return true\n  `);\n}\n\nexport async function createNewTab(): Promise<void> {\n  await runAppleScript(`\n    tell application \"Google Chrome\"\n      make new tab at end of tabs of window 1\n      activate\n    end tell\n    return true\n  `);\n}\n\nexport async function createNewTabToWebsite(website: string): Promise<void> {\n  await runAppleScript(`\n    tell application \"Google Chrome\"\n      activate\n      open location \"${website}\"\n    end tell\n    return true\n  `);\n}\n\nexport async function createNewIncognitoWindow(): Promise<void> {\n  await runAppleScript(`\n    tell application \"Google Chrome\"\n      make new window with properties {mode:\"incognito\"}\n      activate\n    end tell\n    return true\n  `);\n}\n", "import fs from \"fs\";\nimport { getLocalStatePath } from \"../util\";\n\nconst getDefaultProfileID = () => {\n  try {\n    const path = getLocalStatePath();\n    const chromeState = fs.readFileSync(path, \"utf-8\");\n    const profiles = JSON.parse(chromeState).profile.info_cache;\n    if (!profiles) {\n      return \"Default\";\n    }\n    return Object.keys(profiles)[0];\n  } catch {\n    return \"Default\";\n  }\n};\n\nexport const defaultChromeProfilePath = [\"Application Support\", \"Google\", \"Chrome\"];\nexport const defaultChromeStatePath = [\"Application Support\", \"Google\", \"Chrome\", \"Local State\"];\nexport const DEFAULT_CHROME_PROFILE_ID = getDefaultProfileID();\nexport const CHROME_PROFILE_KEY = \"CHROME_PROFILE_KEY\";\nexport const CHROME_PROFILES_KEY = \"CHROME_PROFILES_KEY\";\n\nexport const DownloadText = `\n  # \uD83D\uDEA8Error: Google Chrome browser is not installed\n  ## This extension depends on Google Chrome browser. You must install it to continue.\n\n  If you have [Homebrew](https://brew.sh/) installed then press \u23CE (Enter Key) to install Google Chrome browser.\n\n  [Click here](https://www.google.com/chrome/) if you want to download manually.\n\n  [![Google Chrome](https://www.google.com/chrome/static/images/chrome-logo-m100.svg)]()\n`;\n\nexport const NoBookmarksText = `\n# \uD83D\uDEA8Error: Google Chrome browser has no bookmarks. Please add some bookmarks to continue using this command.\n\n[![Google Chrome](https://www.google.com/chrome/static/images/chrome-logo-m100.svg)]()\n`;\n\nexport const UnknownErrorText = `\n# \uD83D\uDEA8Error: Something happened while trying to run your command\n\n[![Google Chrome](https://www.google.com/chrome/static/images/chrome-logo-m100.svg)]()\n`;\n\nexport const DEFAULT_ERROR_TITLE = \"An Error Occurred\";\n\nexport const NOT_INSTALLED_MESSAGE = \"Google Chrome not installed\";\nexport const NO_BOOKMARKS_MESSAGE = \"Google Chrome has no bookmarks.\";\n", "import fs from \"fs\";\nimport path from \"path\";\nimport {\n  DEFAULT_CHROME_PROFILE_ID,\n  defaultChromeProfilePath,\n  defaultChromeStatePath,\n  NO_BOOKMARKS_MESSAGE,\n} from \"../constants\";\nimport { getPreferenceValues } from \"@raycast/api\";\nimport { Preferences } from \"../interfaces\";\nimport { BookmarkDirectory, HistoryEntry, RawBookmarks } from \"../interfaces\";\n\ntype ChromeFile = \"History\" | \"Bookmarks\";\nconst userLibraryDirectoryPath = () => {\n  if (!process.env.HOME) {\n    throw new Error(\"$HOME environment variable is not set.\");\n  }\n\n  return path.join(process.env.HOME, \"Library\");\n};\nconst getChromeFilePath = (fileName: ChromeFile, profile?: string) => {\n  const { profilePath } = getPreferenceValues<Preferences>();\n  let resolvedProfilePath;\n  if (profilePath) {\n    resolvedProfilePath = path.join(profilePath, fileName);\n  } else {\n    resolvedProfilePath = path.join(\n      userLibraryDirectoryPath(),\n      ...defaultChromeProfilePath,\n      profile ?? DEFAULT_CHROME_PROFILE_ID,\n      fileName,\n    );\n  }\n\n  return resolvedProfilePath;\n};\n\nexport const getHistoryDbPath = (profile?: string) => getChromeFilePath(\"History\", profile);\n\nexport const getLocalStatePath = () => path.join(userLibraryDirectoryPath(), ...defaultChromeStatePath);\n\nconst getBookmarksFilePath = (profile?: string) => getChromeFilePath(\"Bookmarks\", profile);\n\nfunction extractBookmarkFromBookmarkDirectory(bookmarkDirectory: BookmarkDirectory): HistoryEntry[] {\n  const bookmarks: HistoryEntry[] = [];\n\n  if (bookmarkDirectory.type === \"folder\") {\n    bookmarkDirectory.children.forEach((child) => {\n      bookmarks.push(...extractBookmarkFromBookmarkDirectory(child));\n    });\n  } else if (bookmarkDirectory.type === \"url\" && bookmarkDirectory.url) {\n    bookmarks.push({\n      id: bookmarkDirectory.id,\n      url: bookmarkDirectory.url,\n      title: bookmarkDirectory.name,\n      lastVisited: new Date(bookmarkDirectory.date_added),\n    });\n  }\n  return bookmarks;\n}\n\nconst extractBookmarks = (rawBookmarks: RawBookmarks): HistoryEntry[] => {\n  const bookmarks: HistoryEntry[] = [];\n  Object.keys(rawBookmarks.roots).forEach((rootKey) => {\n    const rootLevelBookmarkFolders = rawBookmarks.roots[rootKey];\n    const bookmarkEntries = extractBookmarkFromBookmarkDirectory(rootLevelBookmarkFolders);\n    bookmarks.push(...bookmarkEntries);\n  });\n  return bookmarks;\n};\n\nexport const getBookmarks = async (profile?: string): Promise<HistoryEntry[]> => {\n  const bookmarksFilePath = getBookmarksFilePath(profile);\n  if (!fs.existsSync(bookmarksFilePath)) {\n    throw new Error(NO_BOOKMARKS_MESSAGE);\n  }\n\n  const fileBuffer = await fs.promises.readFile(bookmarksFilePath, { encoding: \"utf-8\" });\n  return extractBookmarks(JSON.parse(fileBuffer));\n};\n\nexport const getDefaultProfileID = () => {\n  try {\n    const path = getLocalStatePath();\n    const chromeState = fs.readFileSync(path, \"utf-8\");\n    const profiles = JSON.parse(chromeState).profile.info_cache;\n    return Object.keys(profiles)[0];\n  } catch {\n    return \"Default\";\n  }\n};\n"],
  "mappings": "0jBAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,aAAAE,IAAA,eAAAC,EAAAH,GAAA,IAAAI,EAAyC,wBCAzC,IAAAC,EAAoB,6BACpBC,EAAwB,qBACxBC,EAAqC,8BAE/BC,KAAgB,aAAU,UAAQ,EAExC,eAAsBC,EAAeC,EAAQ,CAAC,oBAAAC,EAAsB,GAAM,OAAAC,CAAM,EAAI,CAAC,EAAG,CACvF,GAAI,EAAAC,QAAQ,WAAa,SACxB,MAAM,IAAI,MAAM,YAAY,EAG7B,IAAMC,EAAkBH,EAAsB,CAAC,EAAI,CAAC,KAAK,EAEnDI,EAAc,CAAC,EACjBH,IACHG,EAAY,OAASH,GAGtB,GAAM,CAAC,OAAAI,CAAM,EAAI,MAAMR,EAAc,YAAa,CAAC,KAAME,EAAQI,CAAe,EAAGC,CAAW,EAC9F,OAAOC,EAAO,KAAK,CACpB,CCnBA,IAAAC,EAAyD,wB,uFCDzD,IAAAC,EAAe,iBCCf,IAAAC,EAAiB,mBAOjB,IAAAC,EAAoC,wBAK9BC,EAA2B,IAAM,CACrC,GAAI,CAAC,QAAQ,IAAI,KACf,MAAM,IAAI,MAAM,wCAAwC,EAG1D,OAAO,EAAAC,QAAK,KAAK,QAAQ,IAAI,KAAM,SAAS,CAC9C,EAoBO,IAAMC,EAAoB,IAAM,EAAAC,QAAK,KAAKC,EAAyB,EAAG,GAAGC,CAAsB,EDpCtG,IAAMC,EAAsB,IAAM,CAChC,GAAI,CACF,IAAMC,EAAOC,EAAkB,EACzBC,EAAc,EAAAC,QAAG,aAAaH,EAAM,OAAO,EAC3CI,EAAW,KAAK,MAAMF,CAAW,EAAE,QAAQ,WACjD,OAAKE,EAGE,OAAO,KAAKA,CAAQ,EAAE,CAAC,EAFrB,SAGX,MAAQ,CACN,MAAO,SACT,CACF,EAGO,IAAMC,EAAyB,CAAC,sBAAuB,SAAU,SAAU,aAAa,EAClFC,EAA4BC,EAAoB,EDyJ7D,eAAsBC,GAAiC,CACrD,MAAMC,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAMpB,CACH,CFjLA,eAAOC,GAAiC,CACtC,GAAI,CACF,QAAM,mBAAgB,EACtB,MAAMC,EAAgB,CACxB,MAAQ,CACN,QAAM,WAAQ,kDAA6C,CAC7D,CACF",
  "names": ["new_window_exports", "__export", "Command", "__toCommonJS", "import_api", "import_node_process", "import_node_util", "import_node_child_process", "execFileAsync", "runAppleScript", "script", "humanReadableOutput", "signal", "process", "outputArguments", "execOptions", "stdout", "import_api", "import_fs", "import_path", "import_api", "userLibraryDirectoryPath", "path", "getLocalStatePath", "path", "userLibraryDirectoryPath", "defaultChromeStatePath", "getDefaultProfileID", "path", "getLocalStatePath", "chromeState", "fs", "profiles", "defaultChromeStatePath", "DEFAULT_CHROME_PROFILE_ID", "getDefaultProfileID", "createNewWindow", "runAppleScript", "Command", "createNewWindow"]
}
